#!/usr/bin/env python

import argparse
from graphillion import GraphSet
import math
import os
import sys

import dnet.core

max_current     = 300
sending_voltage = 6600 / math.sqrt(3)
voltage_range   = (6300 / math.sqrt(3), 6900 / math.sqrt(3))

switch2edge = {}  # XXX move to dnet.Network

def define_subgraphs():
    edges = []
    sorted_sections = []
    for s in sorted(nw.switches):
        ns = set()
        for t in nw.find_neighbors(s):
            if t in nw.sections:
                ns.add(t)
        neighbors = set()
        is_root = False
        for t in sorted(ns):
            for u in nw.find_neighbors(t):
                if u in nw.sections and u < t:
                    t = u
            neighbors.add(t)
            if t not in sorted_sections:
                sorted_sections.append(t)
        edge = tuple([sorted_sections.index(t) + 1 for t in sorted(neighbors)])
        assert len(edge) == 2
        edges.append(edge)
        switch2edge[s] = edge
    assert len(edges) == len(nw.switches)

    roots = set()
    for s in nw.sections:
        if nw.sections[s]['substation']:
            for t in nw.find_neighbors(s):
                if t < s:
                    s = t
            roots.add(sorted_sections.index(s) + 1)
    assert len(roots) == len(nw.get_root_sections())

    GraphSet.set_universe(edges, traversal='as-is')
    return GraphSet.forests(roots=roots, is_spanning=True)

def find_neighbor_switches(s, processed_sections):
    switches = set()
    if s in nw.switches:
        for t in nw.find_neighbors(s) - processed_sections:
            assert t in nw.sections
            processed_sections.add(t)
            for u in find_neighbor_switches(t, processed_sections.copy()):
                switches.add(u)
    else:
        processed_sections.add(s)
        for t in nw.find_neighbors(s) - processed_sections:
            if t in nw.switches:
                switches.add(t)
            else:
                for u in find_neighbor_switches(t, processed_sections.copy()):
                    switches.add(u)
    return switches - set([s])

def find_surrounding_switches(root, closed_switches):
    if len(closed_switches) > 0:
        return set([t for s in closed_switches for t in find_neighbor_switches(s, set())]) - \
            closed_switches
    else:
        return find_neighbor_switches(root, set())

def find_border_switches(root):
    assert nw.sections[root]['substation']
    border = set()
    for r in nw.get_root_sections() - set([root]):
        for s in find_neighbor_switches(r, set()):
            border.add(s)
    return border

def is_tree(branches):
    '''inspired by networkx.algorithms.cycles'''
    gnodes = set(dnet.core.flatten(branches))
    while gnodes:
        root = gnodes.pop()
        stack = [root]
        pred = { root: root }
        used = { root: set() }
        while stack:
            z = stack.pop()
            zused = used[z]
            nbrs = set([e[1] for e in branches
                        if e[0] == z] + [e[0] for e in branches if e[1] == z])
            for nbr in nbrs:
                if nbr not in used:
                    pred[nbr] = z
                    stack.append(nbr)
                    used[nbr] = set([z])
                elif nbr not in zused:
                    return False
        gnodes -= set(pred)
        root = None
    return True

def satisfies_electric_constraints(root, closed_switches):
    branches = nw.build_tree(root, closed_switches, set())
    if not dnet.core.is_tree(branches):
        return False

    current = nw.calc_current(root, branches)
    if abs(current[root][0]) > max_current or \
            abs(current[root][1]) > max_current or \
            abs(current[root][2]) > max_current:
        return False
    assert len(current) == len(set(dnet.core.flatten(branches)))

    leaves = set(dnet.core.flatten(branches)) - set([b[0] for b in branches])
    for s in leaves:
        voltage_drop = [current[s][i] * nw.sections[s]['impedance'][i] / 2 for i in range(3)]
        bs = [b for b in branches if b[1] == s]
        assert len(bs) == 1
        s, t = bs[0]
        while True:
            voltage_drop = \
                [voltage_drop[i] + current[s][i] * nw.sections[s]['impedance'][i] for i in range(3)]
            upper_branch = [b for b in branches if b[1] == s]
            assert len(upper_branch) <= 1
            if len(upper_branch) == 1:
                s, t = upper_branch[0]
            else:
                break
        if abs(sending_voltage - voltage_drop[0]) < voltage_range[0] or \
                abs(sending_voltage - voltage_drop[1]) < voltage_range[0] or \
                abs(sending_voltage - voltage_drop[2]) < voltage_range[0] or \
                voltage_range[1] < abs(sending_voltage - voltage_drop[0]) or \
                voltage_range[1] < abs(sending_voltage - voltage_drop[1]) or \
                voltage_range[1] < abs(sending_voltage - voltage_drop[2]):
            return False

    return True

def write_bitmap(closed_switches, open_switches):
    closed_switches = [switch2edge[s] for s in closed_switches]
    open_switches = [switch2edge[s] for s in open_switches]
    return GraphSet({'include': closed_switches, 'exclude': open_switches})

def do_enumerate_bitmaps(root, closed_switches, fixed_switches):
    gs = GraphSet()
    unfixed_switches = find_surrounding_switches(root, closed_switches) - fixed_switches
    if len(unfixed_switches) == 0:
        return gs
    s = sorted(unfixed_switches)[0]
    fixed_switches.add(s)
    gs |= do_enumerate_bitmaps(root, closed_switches.copy(), fixed_switches.copy())
    closed_switches.add(s)
    if satisfies_electric_constraints(root, closed_switches):
        gs |= write_bitmap(closed_switches, find_surrounding_switches(root, closed_switches))
        gs |= do_enumerate_bitmaps(root, closed_switches.copy(), fixed_switches.copy())
    return gs

def enumerate_bitmaps(root):
    gs = GraphSet()
    if satisfies_electric_constraints(root, set()):
        gs = write_bitmap(set(), find_surrounding_switches(root, set()))
    return gs | do_enumerate_bitmaps(root, set(), find_border_switches(root))

if __name__ == '__main__':
    parser = argparse.ArgumentParser(
        description='enumerate feasible configurations.')
    parser.add_argument('data_file', type=file,
                        help='network data in YAML')
    parser.add_argument('result_dir', type=str, nargs='?', default='.',
                        help='directory of result files')
    args = parser.parse_args()
    result_dir = args.result_dir

    nw = dnet.core.Network(args.data_file)
    gs = define_subgraphs()

    for root in nw.get_root_sections():
        gs &= enumerate_bitmaps(root)

    gs.dump(open('%s/diagram2' % result_dir, 'w'))
